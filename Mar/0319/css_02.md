# CSS 전체 요소 선택자
```css
* {
    color: black;
}
```
- 문서의 모든 요소를 선택하기 때문에 유용해보이지만, 크기가 큰 문서에 있어서 다소 비효율적일 수 있음
- 다른 방법도 있기 때문에 추천하는 방식은 아님
```css
h1, h2 {
    color: black;
}
```
- 쉼표를 이용해서 목록에 있는 특정 타입의 선택자 여럿을 합칠 수 있음. 이 경우는 아주 빈번하게 사용됨.

# ID 선택자
```css
#logout {
    color: black;
}
```
- id는 label과 input을 연결해주는 것 뿐만 아니라 모든 요소에 접근할 수 있게 함
<!-- coolers.co 색상배합 웹사이트 -->
- #를 통해 아이디를 훅할수 있음
- 중요한 점은 하나의 아이디는 페이지에 하나만 나와야 함. 절대 중복 X
- 마크업에 ID를 추가하고 ID 이름으로 추가하고 ID 앞에서는 꼭 해시표시
- ID를 많이 만드는 것은 좋지 않음. 되도록 한 페이지에 열 개 이내로 쓰는 것이 좋음 (이유는 class가 있기 때문)

# 클래스 선택자
```css
.complete {
    color: green;
}
```
- ID와 비슷하게 마크업에 추가해서 훅을 걸어 css로 연결, 단 클래스는 여러 요소를 묶어주기 때문에 그룹에 비슷한 스타일을 적용할 수 있음
- ID의 # 대신 .을 사용함
- label같은 스티커 개념
- ID보다 훨씬 더 자주 사용하게 됨

# 자손 선택자
```css
li a {
    color: teal;
}
```
- 공백이 ,와 다른 점이 중요함. ','는 두 요소를 같이 선택하지만, 공백은 위 코드를 예를 들면 li 안의 a만 선별하여 선택
- footer 안의 nav 안의 li 안의 a에 적용하고 싶을 때도 footer a 만 사용하면 footer 안의 a에 적용

# 인접 선택자와 직계 자손 선택자
```css
h1 + p {
    color: black;
}
```
- '+' 부호가 인접 선택자로 모든 h1 바로 다음에 오는 p 태그를 선택함
- 부모이 개념이 아니라 형제의 개념

```css
div > li {
    color: white;
}
```
- '>' 표시를 사용해서 직계자손 선택자를 사용할 수 있음
- div 아래 있는 모든 li를 선택하는 것이 아니라 div 의 바로 아래 있는 li를 선택함
- 즉 div 안의 nav 안에 li가 있다면 선택하지 않음
- 자주 쓰지는 않음

# 속성 선택자
```css
input[type="text"] {
    width: 300px;
    color: yellow;
}
```
- 특정 속성을 가진 요소를 선택함
- 위 코드를 예를 들면 대괄호를 이용해서 수 많은 input 중에 type="text"인 것만 선택한다는 의미
- section[class="post"] 을 쓰고 싶은데 class="post"가 section이외에도 여러 군데 적용되어있다면?
  혹은 그 클래스가 있는 section만 선택하고 싶다면?
  section.post 를 쓰면 post라는 클래스가 있는 section만 골라줌.
- 이러한 구문은 자주 쓰이지는 않는데, 그 이유는 바로 *=를 추가하는 방법이 있기 때문
```css
a[href*="google"] {
    font-size: 2em;
}
```
- 위 코드는 href 속서에 example이 포함된 모든 앵커 태그라는 뜻
```css
a[href$=".org"] {
    font-size: 2em;
}
```
- 비슷한 예로 $=".org"는 .org로 끝나는 모든 href를 뜻함

# 가상 클래스
- 가상 클래스는 선택자 끝에 붙여 상태를 특정하는 키워드
 - :active
   :checked
   :first
   :first-child
   :hover
   :not()
   :nth-child()
   nth-of-type()
- 이 것으로 체크된 박스 혹은 호버된 링크 등등을 특정지을 수 있음
- 가상 클래스를 사용하려면 :를 붙여야 함

```css
a:hover {
    font-size: 2em;
}
```
- 특정 상황에서 효과를 설명해줌
- 특정한 반응이나 다른 시각적 효과를 통해 상호작용할 수 있음을 알려줌
```css
.post button:active {
    background-color: red;
}
```
```css
.post:nth-of-type(3){
    background-color: navy;
}
```
- nth-of-type은 같은 요소가 여러 개 나열되어있을 경우 3번째에만 속성을 적용
- 3 대신 3n을 넣으면 매 3번째마다 스타일을 적용할 수 있음

# 가상 요소
- 모디파이어나 선택자처럼 덧붙일 수 있는 요소이지만 선택된 요소의 "특정부분"만 선택함
- 즉, 어떤 요소의 첫 줄의 첫 글자에만 스타일을 넣을 수도 있음
```css
p::first-letter {
    color: red;
    font-size: 130%;
}
```
- 위 코드는 페이지 내의 모든 <p>의 첫번째 글자만 선택해서 스타일을 적용함

 - ::after -> 액션이 적용된 후
 - ::before -> 액션이 적용되기 전
 - ::first-letter -> 첫번째 글자
 - ::first-line -> 첫번째 줄
 - ::selection -> 선택했을 경우 (드래그)

# 캐스케이딩
- 스타일의 최상단부터 출발한 폭포(cascade)가 아래로 쭉 흘르는 것과 같이 적용된 스타일의 순서가 매우 중요함
```css 
h1 {
    color: red;
}
h1 {
    color: purple;
}
```
- 위 코드처럼 동일한 영역에 다른 효과를 준 경우 폭포 효과로 첫번째로 적용된 효과가 두번째로 적용된 효과로 대체됨
- css 파일을 외부링크 했을 때도 링크된 순서에 따라 똑같이 폭포 효과가 적용됨

# 명시도(Specificidy)
```css 
h1 {
    color: red;
}
h1 {
    color: purple;
}
```
- 위 코드의 경우 모든 h1에 빨간색을 적용하라고 하고 그 뒤에 h1에 또 보라색을 적용하라고 명시되었기 때문에,
  이 둘은 정확히 같은 선택자이므로 순서대로 적용됨. 하지만 선택자가 다른 경우라면?
- Specificidy는 충돌이 생길 경우 브라우저에서 규칙을 적용하는 방법
```css
.post button:hover {
    background-color: crimson;
    color: white;
}
button:hover {
    background-color: olive;
    font-size: 10px;
}
```
- 하나 이상의 스타일이 동일한 대상에 적용되면 서로 충돌함
- 위 코드를 예로 들면, post 라는 클래스 안에 있는 버튼에 마우스를 대면 빨간색으로 변경하라는 선택자와 
  마우스를 대면 모든 버튼을 초록색으로 바꾸라는 선택자가 충돌함
- 이러한 상황에서 브라우저는 주어진 선택자가 얼마나 구체적인지 측정한 뒤 더 구체적인 선택자를 우선적으로 선택함.
- 이 경우에는 위의 코드가 아래 코드보다 더 구체적이라고 인식한 것.
- 실제로 적용되는 수학식이 존재하지만 거기까지 알 필요는 없음
- 대충 Element Selector 보다 Element Selector + Element Selector가 더 구체적이라고 보면 됨.
- 이는 일반적인 경우고, 사실 그렇게 간단하지는 않음
```
ID >
CLASS >
ELEMENT
```
- 가장 구체적인 것은 ID로 어떤 요소와 클래스보다 우선시됨
- 세 자리수이 숫자로 ID는 첫번째 자릿수, 클래스는 두번째, 요소는 세번째 자리수에 들어가면서 계산하는 방식으로
  예를들어 아이디 하나가 들어가면 100점이지만, 클래스 하나와 요소 2개가 들어가도 012, 즉 12점이기 때문에
  ID가 우선시됨
- 다시 위의 충돌하는 두 코드를 보면 위의 코드는 클래스 2개와 1개의 요소 즉, 21점이고, 아래의 코드는 
  1개의 클래스와 1개의 요소이기 때문에 11점이 됨.
- 따라서 배경색상의 경우 첫번째 코드를 따르지만, 폰트사이즈는 그대로 적용이 됨 (충돌이 안되기 때문)
- 한 가지 중요한 점은, 이 계산식은 전형적인 10진법이 아니기 때문에 요소선택자가 28개가 있어도 (28점)
  클래스 1개(10점)를 이길 수 없음

# 인라인스타일과 중요도
- 인라인 스타일 (style = "")은 ID 보다도 우선시됨. 자주 쓰지 않는 것이 좋음.
- 왜냐하면 적용된 스타일이 전부 css에 있을때 따로 있으면 찾기도 어렵고 헷갈림.
- !important 도 되도록 안쓰는게 좋음. 이 태그는 브라우저가 가장 중요한 것으로 인식함
- 엄밀히 말하면 별개의 존재로, 모든 중요도의 개념을 무시하는 전혀 다른 존재인 것.
- 시스템 전체를 엎어버릴 수 있지만 아주 가끔 편리할 수 있음. (무언가를 바꾸거나 덮어쓰고 싶을 때)

# CSS 상속
- CSS 상속이란 구체적인 특성을 지정하지 않은 하위 요소에 상위 항목 특성이 적용되는 것
- 예를들어 body 안의 div 안의 h1이 있고, h1에만 스타일이 적용되어 있고 body에 같은 종류의 스타일을 다르게 적용하면, h1을 제외한 다른 요소에 
  상위 항목의 스타일(body)이 적용되는 것.
- input 등 일부 항목은 기본적으로 상속받지 않도록 설정되어있지만 이런 경우에도 inherit; 을 통해 속성을 받도록 바꿀 수 있음